# Access via MACRO_IMPORT bytecodemanipulation.standard_library
# and than either CALL MACRO std:..., or for macros marked with ASSEMBLY, directly with std:...


NAMESPACE std
{

    # Wrapper around the print builtin
    MACRO ASSEMBLY print(text VARIABLE_ARG)
    {
        CALL ~print (*&text)
        POP
    }

    # Wrapper around the input builtin
    MACRO ASSEMBLY input(result VARIABLE, text VARIABLE_ARG)
    {
        CALL ~input (*&text) -> &result
    }

    MACRO ASSEMBLY check_type(expected_type, value, error_message)
    {
        IF OP (not ~isinstance(&value, &expected_type))
        {
            RAISE ~ValueError(&error_message)
        }
    }

    MACRO ASSEMBLY check_type(expected_type, value)
    {
        check_type(&expected_type, &value, OP ("Invalid type, expected " + ~repr(&value)))
    }

    NAMESPACE os
    {
        MACRO ASSEMBLY file_walker(directory, file VARIABLE, code CODE_BLOCK)
        {
            CALL ~os.!listdir(&directory) -> $files

            LOAD 0 -> $counter
            CALL ~len($files) -> $file_count

            WHILE OP ($counter < $file_count)
            {
                LOAD $files[$counter] -> &file
                OP $counter + 1 -> $counter

                IF ~os.!path.!isfile(&file)
                {
                    MACRO_PASTE &code
                }
            }
        }
    }

    NAMESPACE comprehension
    {
        MACRO ASSEMBLY list(iterable, var VARIABLE, code CODE_BLOCK) -> ANY
        {
            DEF inner<&iterable>(iter_obj)
            {
                LOAD ~list() -> $__unique
                FOREACH &var IN ยง&iterable
                {
                    MACRO_PASTE code
                    CALL $__unique.append(%) -> \
                }
                RETURN $__unique
            }

            MACRO_RETURN $inner(~iter(&iterable))
        }
    }

    NAMESPACE stream
    {
        MACRO ASSEMBLY initialize(var VARIABLE)
        {
            LOAD ~list() -> &var
        }

        MACRO ASSEMBLY extend(var VARIABLE, value)
        {
            CALL &var.extend(&value) -> \
        }

        MACRO ASSEMBLY filter(var VARIABLE, predicate CODE_BLOCK[1])
        {
            DEF filtered(item)
            {
                MACRO_PASTE predicate [$item]
                RETURN %
            }

            LOAD &var.copy() -> $tmp
            CALL &var.clear() -> \
            CALL &var.extend(~filter($filtered, $tmp)) -> \
        }

        MACRO ASSEMBLY map(var VARIABLE, predicate CODE_BLOCK[1])
        {
            DEF mapping(item)
            {
                MACRO_PASTE predicate [$item]
                RETURN $item
            }

            LOAD &var.copy() -> $tmp
            CALL &var.clear() -> \
            CALL &var.extend(~map($mapping, $tmp)) -> \
        }

        MACRO ASSEMBLY reduce(var VARIABLE, reducer CODE_BLOCK[2])
        {
            IF OP (~len(&var) == 0)
            {
                RETURN -1
            }

            LOAD &var[0] -> $tmp

            LOAD 1 -> $index
            LOAD ~len(&var) -> $max_size

            WHILE OP ($index < $max_size)
            {
                MACRO_PASTE &reducer [$tmp, &var[$index]] -> $tmp
                OP $index + 1 -> $index
            }

            LOAD $tmp
        }

        MACRO ASSEMBLY to_list(var VARIABLE, output VARIABLE)
        {
            LOAD ~list(&var) -> &output
        }
    }
}
